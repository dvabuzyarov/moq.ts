<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>moq.ts | documentation</title>
	<meta name="description" content="Documentation for moq.ts | documentation">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">moq.ts | documentation</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>moq.ts | documentation</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><a href="https://travis-ci.org/dvabuzyarov/moq.ts"><img src="https://travis-ci.org/dvabuzyarov/moq.ts.svg?branch=master" alt="Build Status"></a>
					<a href="https://www.npmjs.com/package/moq.ts"><img src="https://img.shields.io/npm/v/moq.ts/latest.svg?style=flat-square" alt="NPM version:latest"></a>
					<a href="https://www.npmjs.com/package/moq.ts"><img src="https://img.shields.io/npm/v/moq.ts/next.svg?style=flat-square" alt="NPM version:next"></a>
					<a href="https://www.npmjs.com/package/moq.ts"><img src="https://img.shields.io/npm/dt/moq.ts.svg?style=flat-square" alt="npm downloads"></a>
					<a href="https://david-dm.org/dvabuzyarov/moq.ts"><img src="http://img.shields.io/david/dvabuzyarov/moq.ts.svg?style=flat-square" alt="Dependency Status"></a>
					<a href="http://commitizen.github.io/cz-cli/"><img src="https://img.shields.io/badge/commitizen-friendly-brightgreen.svg" alt="Commitizen friendly"></a>
					<a href="https://github.com/semantic-release/semantic-release"><img src="https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg" alt="semantic-release"></a>
					<a href="https://renovatebot.com/"><img src="https://img.shields.io/badge/renovate-enabled-brightgreen.svg" alt="Renovate enabled"></a>
					<a href="https://www.npmjs.com/package/moq.ts"><img src="https://img.shields.io/bundlephobia/minzip/moq.ts.svg" alt="npm bundle size (minified + gzip)"></a>
				<a href="https://www.npmjs.com/package/moq.ts"><img src="https://img.shields.io/hexpm/l/plug.svg" alt="License"></a></p>
				<a href="#moqts--documentation" id="moqts--documentation" style="color: inherit; text-decoration: none;">
					<h1>moq.ts | <a href="https://dvabuzyarov.github.io/moq.ts/">Documentation</a></h1>
				</a>
				<p>Moq for Typescript. Inspired by c# <a href="https://github.com/moq/moq4">Moq library</a>.</p>
				<a href="#install" id="install" style="color: inherit; text-decoration: none;">
					<h4>Install</h4>
				</a>
				<p>npm install moq.ts --save-dev</p>
				<a href="#quick-start" id="quick-start" style="color: inherit; text-decoration: none;">
					<h4>Quick start</h4>
				</a>
				<p>moq.ts as the original <a href="https://github.com/moq/moq4">Moq library</a> is intended to be simple to use, strongly typed (no
					magic strings!, and therefore full compiler-verified and refactoring-friendly) and minimalistic (while still fully
					functional!). Every each mock is an instance
				of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> object.</p>
				<p>You can find a pretty full set of usages in the integration tests. Check
				out <a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/integration.specs/">tests.integration</a> folder.</p>
				<hr>
				<ul>
					<li><a href="#mocking-functions-of-objects">Mocking functions of objects</a></li>
					<li><a href="#mocking-reading-properties">Mocking reading properties</a></li>
					<li><a href="#mocking-writing-property">Mocking writing property setting</a></li>
					<li><a href="#mocking-functions">Mocking functions</a></li>
					<li><a href="#auto-mocking">Auto mocking</a></li>
					<li><a href="#async-await">async/await</a></li>
					<li><a href="#type-discovering">Type Discovering</a></li>
					<li><a href="#mock-behavior">Mock behavior</a><ul>
							<li><a href="#injector-config">Injector config</a><ul>
									<li><a href="#defaultinjectorconfig">DefaultInjectorConfig</a></li>
									<li><a href="#equalmatchinginjectorconfig">EqualMatchingInjectorConfig and custom matchers</a></li>
									<li><a href="#internal-api">Internal API</a></li>
								</ul>
							</li>
						</ul>
					</li>
					<li><a href="#mock-prototype">Mock prototype</a></li>
					<li><a href="#mimics">Mimics</a></li>
					<li><a href="#typeof-operator">typeof operator</a></li>
					<li><a href="#in-operator">in operator</a></li>
					<li><a href="#new-operator">new operator</a></li>
					<li><a href="#moqapi-symbol">MoqAPI symbol</a></li>
				</ul>
				<hr>
				<!-- toc -->
				<a href="#mocking-functions-of-objects" id="mocking-functions-of-objects" style="color: inherit; text-decoration: none;">
					<h2>Mocking functions of objects</h2>
				</a>
				<p><a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/integration.specs/instance-method.spec.ts">instance-method.spec.ts</a></p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Mock, It, Times } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-keyword">interface</span> ITestObject {
   method(arg1: <span class="hljs-built_in">number</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Date</span>;
}

<span class="hljs-keyword">const</span> values = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;ITestObject&gt;()
   .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.method(<span class="hljs-number">1</span>, values[<span class="hljs-number">0</span>]))
   .returns(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>))

   .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.method(It.Is(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value === <span class="hljs-number">2</span>), values[<span class="hljs-number">1</span>]))
   .callback(<span class="hljs-function">(<span class="hljs-params">{args: [arg1, arg2]}</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2017</span> + arg1))

   .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.method(<span class="hljs-number">3</span>, It.Is(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value === values[<span class="hljs-number">2</span>])))
   .throws(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Invoking method with 3 and c&quot;</span>));

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();
<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>.method(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>);

mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.method(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>), Times.Never());
</code></pre>
				<a href="#mocking-reading-properties" id="mocking-reading-properties" style="color: inherit; text-decoration: none;">
					<h2>Mocking reading properties</h2>
				</a>
				<p><a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/integration.specs/read-property.spec.ts">read-property.spec.ts</a></p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Mock, It, Times, GetPropertyExpression } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-keyword">interface</span> ITestObject {
    <span class="hljs-attr">property1</span>: <span class="hljs-built_in">number</span>;
    property2: <span class="hljs-built_in">number</span>;
    property3: <span class="hljs-built_in">number</span>;
    property4: <span class="hljs-built_in">number</span>;

    method(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">const</span> property4Name = <span class="hljs-string">&quot;property4&quot;</span>;
<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;ITestObject&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.property1)
    .returns(<span class="hljs-number">1</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> It.Is(<span class="hljs-function">(<span class="hljs-params">expression: GetPropertyExpression</span>) =&gt;</span> expression.name === <span class="hljs-string">&quot;property2&quot;</span>))
    .returns(<span class="hljs-number">100</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.property3)
    .callback(<span class="hljs-function">() =&gt;</span> <span class="hljs-number">10</span> + <span class="hljs-number">10</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance[property4Name])
    .throws(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;property4 access&quot;</span>))

    <span class="hljs-comment">//since a method is a property that holds a pointer to a function</span>
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.method)
    .returns(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The method was called&quot;</span>)
    });

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();
<span class="hljs-built_in">object</span>.method();

mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.property1, Times.Never());
</code></pre>
				<a href="#mocking-writing-properties" id="mocking-writing-properties" style="color: inherit; text-decoration: none;">
					<h2>Mocking writing properties</h2>
				</a>
				<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set">The documentation on returned value from &quot;set hook&quot; on Proxy object</a></p>
				<p><a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/integration.specs/set.property.spec.ts">set-property.spec.ts</a></p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Mock, It, Times, SetPropertyExpression } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-keyword">interface</span> ITestObject {
    <span class="hljs-attr">property</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">const</span> value = {<span class="hljs-attr">field</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()};

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;ITestObject&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
        instance.property = <span class="hljs-number">1</span>
    })
    <span class="hljs-comment">//true - allows the write operation</span>
    .returns(<span class="hljs-literal">true</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> It.Is(<span class="hljs-function">(<span class="hljs-params">expression: SetPropertyExpression</span>) =&gt;</span> expression.name === <span class="hljs-string">&quot;property&quot;</span> &amp;&amp; expression.value === <span class="hljs-number">2</span>))
    <span class="hljs-comment">//false - denies the write operation</span>
    .returns(<span class="hljs-literal">false</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
        instance.property = It.Is(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value === <span class="hljs-number">3</span>)
    })
    <span class="hljs-comment">// allows the write operation</span>
    .callback(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
        instance.property = value
    })
    .throws(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;an object has been written into property&quot;</span>));


<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();
<span class="hljs-built_in">object</span>.property = <span class="hljs-number">1</span>;

mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> {
    instance.property = <span class="hljs-number">1</span>
}, Times.Once());
</code></pre>
				<a href="#mocking-functions" id="mocking-functions" style="color: inherit; text-decoration: none;">
					<h2>Mocking functions</h2>
				</a>
				<p><a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/integration.specs/method.spec.ts">mock-method.property.IntegrationTests.ts</a></p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Mock, It, Times } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-keyword">interface</span> ITestFunction {
    (arg: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">any</span>): <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> value = {<span class="hljs-attr">field</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()};

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;ITestFunction&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(<span class="hljs-number">1</span>))
    .returns(<span class="hljs-string">&quot;called with 1&quot;</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(<span class="hljs-number">2</span>))
    .callback(<span class="hljs-function">(<span class="hljs-params">{args: [argument]}</span>) =&gt;</span> argument === <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;called with 2&quot;</span> : <span class="hljs-string">`called with <span class="hljs-subst">${argument}</span>`</span>)

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(value))
    .throws(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Argument is object with date&quot;</span>))

    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(It.Is(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value === <span class="hljs-number">4</span>)))
    .returns(<span class="hljs-string">&quot;called with 4&quot;</span>);

<span class="hljs-keyword">const</span> method = mock.object();
<span class="hljs-keyword">const</span> actual = method(<span class="hljs-number">1</span>);

mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(<span class="hljs-number">1</span>), Times.Once());
mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(It.Is(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value === <span class="hljs-number">1</span>)), Times.Exactly(<span class="hljs-number">1</span>));

</code></pre>
				<a href="#auto-mocking" id="auto-mocking" style="color: inherit; text-decoration: none;">
					<h2>Auto mocking</h2>
				</a>
				<p>The library support auto mocking for deep members. Consider this case:</p>
				<pre><code class="language-typescript">
<span class="hljs-keyword">interface</span> IChild {
    get(): <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IRoot {
    <span class="hljs-attr">child</span>: IChild;
}

<span class="hljs-keyword">const</span> value = <span class="hljs-string">&quot;value&quot;</span>;

<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Mock&lt;IChild&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.get())
    .returns(value)
    .object();

<span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> Mock&lt;IRoot&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.child)
    .returns(child)
    .object();

<span class="hljs-keyword">const</span> actual = root.child.get();

expect(actual).toBe(value);
</code></pre>
				<p>We have to create a child mock in order to set up &quot;child&quot; property of the root object. With auto mocking this case could
				be rewritten as following:</p>
				<pre><code class="language-typescript">
<span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> Mock&lt;IRoot&gt;()
    <span class="hljs-comment">// The root mock automatically creates a mock for the child property</span>
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.child.get())
    .returns(value)
    .object();

<span class="hljs-keyword">const</span> actual = root.child.get();

expect(actual).toBe(value);
</code></pre>
				<a href="#asyncawait" id="asyncawait" style="color: inherit; text-decoration: none;">
					<h2>async/await</h2>
				</a>
				<p>The library supports asynchronous function with a promise-based wrappers. There are two overloading:</p>
				<ul>
					<li>returnsAsync - returns a Promise which will be resolved with the provided value;</li>
					<li>throwsAsync - returns a Promise which will be rejected with the provided exception;</li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">input: <span class="hljs-built_in">number</span></span>) </span>{
    <span class="hljs-keyword">return</span> input;
}

<span class="hljs-keyword">const</span> exception = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();
<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-keyword">typeof</span> fn&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(<span class="hljs-number">1</span>))
    .returnsAsync(<span class="hljs-number">2</span>)
    <span class="hljs-comment">// equal to</span>
    <span class="hljs-comment">// .returns(Promise.resolve(2))</span>
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(<span class="hljs-number">2</span>))
    .throwsAsync(exception)
    <span class="hljs-comment">// equal to</span>
    <span class="hljs-comment">// .returns(Promise.reject(exception))</span>
    .object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-keyword">await</span> mock(<span class="hljs-number">1</span>);
expect(actual).toBe(<span class="hljs-number">2</span>);

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> mock(<span class="hljs-number">2</span>);
} <span class="hljs-keyword">catch</span> (e) {
    expect(e).toBe(exception);
}
</code></pre>
				<a href="#eslint-typescript-eslintpromise-function-async-rule" id="eslint-typescript-eslintpromise-function-async-rule" style="color: inherit; text-decoration: none;">
					<h4>ESLint <a href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/promise-function-async.md">@typescript-eslint/promise-function-async</a> rule</h4>
				</a>
				<p>This rule will ask you to write setup with async keyword.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-keyword">typeof</span> fn&gt;()
    .setup(<span class="hljs-keyword">async</span> instance =&gt; instance(<span class="hljs-number">1</span>))
    .returnsAsync(<span class="hljs-number">2</span>)
    .setup(<span class="hljs-keyword">async</span> instance =&gt; instance(<span class="hljs-number">2</span>))
    .throwsAsync(exception)
    .object();
</code></pre>
				<p>That will interfere the auto-mocking feature. You can disable the auto-mocking feature with a custom implementation
					of <a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/expression-reflector.ts">ExpressionReflector</a>
				or override the returnsAsync and throwsAsync implementation.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { EqualMatchingInjectorConfig, Mock } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

Mock.options = {
    <span class="hljs-attr">injectorConfig</span>: <span class="hljs-keyword">new</span> EqualMatchingInjectorConfig([], [
        {
            <span class="hljs-attr">provide</span>: ReturnsAsyncPresetFactory,
            <span class="hljs-attr">useClass</span>: MimicsResolvedAsyncPresetFactory,
            <span class="hljs-attr">deps</span>: [RootMockProvider, Presets, ResolvedPromiseFactory]
        },
        {
            <span class="hljs-attr">provide</span>: ThrowsAsyncPresetFactory,
            <span class="hljs-attr">useClass</span>: MimicsRejectedAsyncPresetFactory,
            <span class="hljs-attr">deps</span>: [RootMockProvider, Presets, RejectedPromiseFactory]
        },
    ])
};
</code></pre>
				<p>With this config you can use async keyword in setup sections.</p>
				<a href="#promise-adapters" id="promise-adapters" style="color: inherit; text-decoration: none;">
					<h3>Promise adapters</h3>
				</a>
				<p>Due to the fact that some environments are not using the native Promise object the library provides adapters for
					resolved/rejected promise that could be overridden.
					See <a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/presets/resolved-promise.factory.ts">ResolvedPromiseFactory</a>
					,
					<a href="https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/presets/rejected-promise.factory.ts">RejectedPromiseFactory</a>
				.</p>
				<a href="#type-discovering" id="type-discovering" style="color: inherit; text-decoration: none;">
					<h2>Type Discovering</h2>
				</a>
				<p>Despite the fact that Mock class is generic type where T parameter is stands for mocked type it works only at design
					time. At the runtime phase the type is not available and Moq library relays on other ways to discover the type
				information. It is required to implement correct behaviour of mocked object.</p>
				<p>Consider this case:</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> </span>{
    method(): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Not Implemented&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> Mock&lt;Prototype&gt;()
    .object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>.method(); <span class="hljs-comment">// throws TypeError: object.method is not a function</span>

expect(actual).toBe(<span class="hljs-literal">undefined</span>);
</code></pre>
				<p>It happens because at runtime the mock does not know that method is a part of the mocked type. So at the moment there
				are 3 ways how type could be discovered at runtime.</p>
				<a href="#target" id="target" style="color: inherit; text-decoration: none;">
					<h4>Target</h4>
				</a>
				<p>It is possible to provide a target object instance when a new instance of mock is being created. It will fix typeof
				operator. The prototype of the target will be used for type discovering and fixing instanceof operator.</p>
				<p>By default, a mock is instantiated as Function object, so at runtime the mock &quot;knows&quot; about Function inherited
				properties and methods.</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> </span>{
    method(): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Not Implemented&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> Mock&lt;Prototype&gt;({<span class="hljs-attr">target</span>: <span class="hljs-keyword">new</span> Prototype()})
    .object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>.method();

expect(actual).toBe(<span class="hljs-literal">undefined</span>);
expect(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-string">&quot;object&quot;</span>);
expect(<span class="hljs-built_in">object</span> <span class="hljs-keyword">instanceof</span> Prototype).toBe(<span class="hljs-literal">true</span>);
</code></pre>
				<a href="#prototype" id="prototype" style="color: inherit; text-decoration: none;">
					<h4>Prototype</h4>
				</a>
				<p>Another way to deal with type discovering is to provide a prototype object.</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> </span>{
    method(): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Not Implemented&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> Mock&lt;Prototype&gt;()
    .prototypeof(Prototype.prototype)
    .object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>.method();

expect(actual).toBe(<span class="hljs-literal">undefined</span>);
expect(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-string">&quot;function&quot;</span>);
expect(<span class="hljs-built_in">object</span> <span class="hljs-keyword">instanceof</span> Prototype).toBe(<span class="hljs-literal">true</span>);
</code></pre>
				<a href="#setup-examination" id="setup-examination" style="color: inherit; text-decoration: none;">
					<h4>Setup examination</h4>
				</a>
				<p>In some cases Moq library can discover type information from provided setup information.</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prototype</span> </span>{
    method(): <span class="hljs-built_in">number</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Not Implemented&quot;</span>);
    }
}

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> Mock&lt;Prototype&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.method()) <span class="hljs-comment">// this would be used for type discovering</span>
    .returns(<span class="hljs-number">2</span>)
    .object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>.method();

expect(actual).toBe(<span class="hljs-number">2</span>);
expect(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-string">&quot;function&quot;</span>);
</code></pre>
				<a href="#mock-behavior" id="mock-behavior" style="color: inherit; text-decoration: none;">
					<h2>Mock behavior</h2>
				</a>
				<p>A mocked object is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>,
					that configured to track any read and write operations on properties. If you write a value to an arbitrary property the
				mocked object will keep it and you can read it later on. By default, the prototype of mocked object is Function.</p>
				<p>Accessing to an unset property or a method will return undefined, or a pointer to a spy function if it exists on
				prototype; You can call this function, and it will be tracked.</p>
				<p>The default behaviour has the lowest precedence. The latest setup has the highest precedence.</p>
				<p>You can control mock behavior when accessing to a property without a corresponding setup.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;ITestObject&gt;();
mock.setup(<span class="hljs-function">() =&gt;</span> It.IsAny())
    .throws(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;setup is missed&quot;</span>));
</code></pre>
				<a href="#injector-config" id="injector-config" style="color: inherit; text-decoration: none;">
					<h4>Injector config</h4>
				</a>
				<p>Internally the library is using an injector that implementation is based
					on <a href="https://angular.io/guide/dependency-injection-providers">Angular injector</a> to create and configure every each Mock
				object that is created with its constructor.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">new</span> Mock() <span class="hljs-comment">// &lt;-- calls angular based injector internally to create all dependencies </span>
</code></pre>
				<p>The library provides an extension point to change the way how mocks are configured internally. It is available through
				IMockOptions.injectorConfig that could be applied globally or per mock instance at the instancing phase.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { EqualMatchingInjectorConfig, Mock } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-comment">// The global configuration that would be overridden with instance options </span>
Mock.options = {<span class="hljs-attr">injectorConfig</span>: <span class="hljs-keyword">new</span> EqualMatchingInjectorConfig()};
<span class="hljs-comment">// or per instance</span>
<span class="hljs-keyword">new</span> Mock({<span class="hljs-attr">injectorConfig</span>: <span class="hljs-keyword">new</span> EqualMatchingInjectorConfig()})
</code></pre>
				<p>Out of the box there are 2 available configurations that change the way how a mock compares expressions.</p>
				<a href="#defaultinjectorconfig" id="defaultinjectorconfig" style="color: inherit; text-decoration: none;">
					<h4>DefaultInjectorConfig</h4>
				</a>
				<p>This is a default configuration that provides the standard mock behaviours.</p>
				<a href="#equalmatchinginjectorconfig" id="equalmatchinginjectorconfig" style="color: inherit; text-decoration: none;">
					<h4>EqualMatchingInjectorConfig</h4>
				</a>
				<p>By default, all values are matched
					with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">Equality comparisons and sameness</a>
					that is limited in matching objects. On the other hand developers are using so called &quot;deep equal comparison&quot; approach,
					where objects are matched by its properties and values. This configuration changes the way how expressions are matched
				and introduce deep equal comparison logic as well as an extension point for custom matchers.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Mock } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-function">(<span class="hljs-params">args: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> <span class="hljs-built_in">number</span>&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]))
    .returns(<span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);

<span class="hljs-comment">// since the default comparisons logic sees [2, 1] and [2, 1] as different objects the provided setup would not work</span>
expect(actual).toBe(<span class="hljs-literal">undefined</span>);
</code></pre>
				<p>and compare with</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { EqualMatchingInjectorConfig, Mock } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-function">(<span class="hljs-params">args: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> <span class="hljs-built_in">number</span>&gt;({<span class="hljs-attr">injectorConfig</span>: <span class="hljs-keyword">new</span> EqualMatchingInjectorConfig()})
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]))
    .returns(<span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);

expect(actual).toBe(<span class="hljs-number">2</span>);
</code></pre>
				<p>Internally the equal comparision logic implemented as a collection of object matchers that implement IObjectMatcher
				interface.</p>
				<p>Matchers with the most specific logic should come first in the collection and if they are not able to match the objects
				then more general matchers would be invoked.</p>
				<p>The library comes with the following matchers:</p>
				<ol start="0">
					<li>Custom matchers</li>
					<li>DateMatcher - matches <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a>
					objects</li>
					<li>MapMatcher - matches <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>
					objects</li>
					<li>IteratorMatcher - matches objects that
					supports <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iterator protocol</a></li>
					<li>POJOMatcher - as the last resort matches objects as <a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">POJO</a>
					objects.</li>
				</ol>
				<p>Here is an example of a custom matcher that matches Moment and Date objects.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;
<span class="hljs-keyword">import</span> { isMoment, utc } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentDateMatcher</span> <span class="hljs-title">implements</span> <span class="hljs-title">IObjectMatcher</span> </span>{
    matched&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt;(left: T, <span class="hljs-attr">right</span>: T): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">undefined</span> {
        <span class="hljs-keyword">if</span> (left <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> &amp;&amp; isMoment(right)) {
            <span class="hljs-keyword">return</span> left.valueOf() === right.valueOf();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    }
}

<span class="hljs-keyword">const</span> moment = utc(<span class="hljs-number">1</span>);
<span class="hljs-keyword">const</span> injectorConfig = <span class="hljs-keyword">new</span> EqualMatchingInjectorConfig([{
    <span class="hljs-attr">provide</span>: OBJECT_MATCHERS,
    <span class="hljs-attr">useClass</span>: MomentDateMatcher,
    <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">deps</span>: []
}]);

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-function">(<span class="hljs-params">args: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>&gt;({injectorConfig})
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance(moment))
    .returns(<span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1</span>));

expect(actual).toBe(<span class="hljs-number">2</span>);
</code></pre>
				<p>The matching logic of EqualMatchingInjectorConfig
					supports <a href="https://raw.githubusercontent.com/dvabuzyarov/moq.ts/master/projects/moq/src/lib/expected-expressions/expression-predicates.ts">It notation</a>
				. So you can do a partial comparision.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { EqualMatchingInjectorConfig, It, Mock } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts&quot;</span>;

<span class="hljs-keyword">const</span> func = <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">undefined</span>;

<span class="hljs-keyword">const</span> injectorConfig = <span class="hljs-keyword">new</span> EqualMatchingInjectorConfig();
<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-function">(<span class="hljs-params">args: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>&gt;({injectorConfig})
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance({<span class="hljs-attr">func</span>: It.IsAny()})) <span class="hljs-comment">// &lt;-- func property will be matched with It delegate</span>
    .returns(<span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();

<span class="hljs-keyword">const</span> actual = <span class="hljs-built_in">object</span>({func});

expect(actual).toBe(<span class="hljs-number">2</span>);
</code></pre>
				<a href="#internal-api" id="internal-api" style="color: inherit; text-decoration: none;">
					<h4>Internal API</h4>
				</a>
				<p>The <strong>moq.ts</strong> library is comprised of small units that follow <a href="https://en.wikipedia.org/wiki/SOLID">SOLID principles</a>.
				Some of those units are included in the public API. The others are part of the <strong>internal API</strong>.</p>
				<p>All of the units are composed together by an IoC container and make the library run. The IoC container&#39;s config is part
					of the public API, and developers can use it to change the behavior of any aspect of the library. In order to do this,
				developers need access to all public and internal units as well.</p>
				<p>The core units are public and are available directly from the moq.ts package. Changes in those units
					follow <a href="https://semver.org">Semantic Versioning</a>, while changes in the internal units do not
				follow <a href="https://semver.org">Semantic Versioning</a> and could produce all types of version increments.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moq.ts/internal&quot;</span>;
</code></pre>
				<blockquote>
					<p>Internal API access provides wide opportunities to customize the library behavior. However,
					the user code that is based on the internal API <strong>could easily be broken</strong> by a new release.</p>
				</blockquote>
				<a href="#mock-prototype" id="mock-prototype" style="color: inherit; text-decoration: none;">
					<h2>Mock prototype</h2>
				</a>
				<p>If you need to make work instanceof operator or you need to deal with prototype of the mock object you can use
					prototypeof function of Mock class. Or you can
					use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf</a>
					or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a>
				functions on mocked object.</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObject</span> <span class="hljs-title">implements</span> <span class="hljs-title">ITestObject</span> </span>{

}

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;ITestObject&gt;()
    .prototypeof(TestObject.prototype)
    .object();

mock.object() <span class="hljs-keyword">instanceof</span> TestObject;<span class="hljs-comment">// true</span>
</code></pre>
				<a href="#mimics" id="mimics" style="color: inherit; text-decoration: none;">
					<h2>Mimics</h2>
				</a>
				<p>If you need to replicate behaviour of an existing object you can reflect mock&#39;s interactions on the object.</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Origin</span> </span>{
    <span class="hljs-keyword">public</span> property = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">public</span> method(input: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
        <span class="hljs-keyword">return</span> input * <span class="hljs-built_in">this</span>.property;
    }
}

<span class="hljs-keyword">const</span> origin = <span class="hljs-keyword">new</span> Origin();

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;Origin&gt;()
    .setup(<span class="hljs-function">() =&gt;</span> It.IsAny())
    .mimics(origin);

<span class="hljs-keyword">const</span> mocked = mock.object();
mocked.property = <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> actual = mocked.method(<span class="hljs-number">2</span>);

expect(actual).toBe(<span class="hljs-number">6</span>);
mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance.method(<span class="hljs-number">2</span>));
</code></pre>
				<a href="#typeof-operator" id="typeof-operator" style="color: inherit; text-decoration: none;">
					<h2>typeof operator</h2>
				</a>
				<p>Some operations are not possible to trap in order to keep the language consistent, one of them is typeof. The type of
					the proxy object will be the same as the proxy target. So at the moment the only available options is to provider target
				option as a create mock parameter.</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Origin</span> </span>{
}

<span class="hljs-keyword">const</span> origin = <span class="hljs-keyword">new</span> Origin();

<span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;Origin&gt;({<span class="hljs-attr">target</span>: <span class="hljs-keyword">new</span> Origin()});

expect(<span class="hljs-keyword">typeof</span> mock.object()).toBe(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> Origin());
</code></pre>
				<a href="#in-operator" id="in-operator" style="color: inherit; text-decoration: none;">
					<h2>in operator</h2>
				</a>
				<p>The library supports <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in">in operator</a>. More
					examples could be
				found <a href="https://raw.githubusercontent.com/dvabuzyarov/moq.ts/master/projects/moq/src/integration.specs/in-operator.spec.ts">here</a></p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;arbitrary name&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> Mock&lt;{}&gt;()
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> name <span class="hljs-keyword">in</span> instance)
    .returns(<span class="hljs-literal">true</span>)
    .object();

expect(name <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-literal">true</span>);
</code></pre>
				<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> ITestObject {
    <span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span>;

    method(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObject</span> <span class="hljs-title">implements</span> <span class="hljs-title">ITestObject</span> </span>{
    <span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span>;

    method(): <span class="hljs-built_in">void</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    }
}

<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> Mock&lt;ITestObject&gt;()
    .prototypeof(TestObject.prototype)
    .object();

<span class="hljs-comment">// because &quot;property&quot; in new TestObject() === false</span>
expect(<span class="hljs-string">&quot;property&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-literal">false</span>);
expect(<span class="hljs-string">&quot;method&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-literal">true</span>);
</code></pre>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;{}&gt;();
<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();

<span class="hljs-keyword">const</span> actual1 = <span class="hljs-string">&quot;property&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>;
<span class="hljs-keyword">const</span> actual2 = <span class="hljs-string">&quot;method&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>;

mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> <span class="hljs-string">&quot;property&quot;</span> <span class="hljs-keyword">in</span> instance, Times.Once());
mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> <span class="hljs-string">&quot;method&quot;</span> <span class="hljs-keyword">in</span> instance, Times.Once());
</code></pre>
				<a href="#new-operator" id="new-operator" style="color: inherit; text-decoration: none;">
					<h2>new operator</h2>
				</a>
				<p>The library supports <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new operator</a>.
					More examples could be
				found <a href="https://raw.githubusercontent.com/dvabuzyarov/moq.ts/master/projects/moq/src/integration.specs/new-operator.spec.ts">here</a></p>
				<blockquote>
					<p>[In order for the new operation to be valid on the resulting Proxy object,
						the target used to initialize the proxy must itself have a [[Construct]] internal method
					(i.e. new target must be valid)](<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/construct">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/construct</a>).</p>
				</blockquote>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObject</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> arg</span>)</span> {
    }
}
</code></pre>
				<pre><code class="language-typescript">    it(<span class="hljs-string">&quot;Returns new object with callback&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> value = <span class="hljs-string">&quot;value&quot;</span>;
    <span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-keyword">typeof</span> TestObject&gt;({<span class="hljs-attr">target</span>: TestObject})
        .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> <span class="hljs-keyword">new</span> instance(value))
        .callback(<span class="hljs-function">(<span class="hljs-params">{args: [name]}</span>) =&gt;</span> <span class="hljs-keyword">new</span> TestObject(name));
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();

    <span class="hljs-keyword">const</span> actual = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>(value);
    expect(actual).toEqual(<span class="hljs-keyword">new</span> TestObject(value));
    mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> <span class="hljs-keyword">new</span> instance(value));
});

it(<span class="hljs-string">&quot;Returns new object with returns&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> value = <span class="hljs-string">&quot;value&quot;</span>;
    <span class="hljs-keyword">const</span> expected = <span class="hljs-keyword">new</span> TestObject(value);
    <span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-keyword">typeof</span> TestObject&gt;({<span class="hljs-attr">target</span>: TestObject})
        .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> <span class="hljs-keyword">new</span> instance(value))
        .returns(expected);
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock.object();

    <span class="hljs-keyword">const</span> actual = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>(value);
    expect(actual).toBe(expected);
    mock.verify(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> <span class="hljs-keyword">new</span> instance(value));
});
</code></pre>
				<a href="#moqapi-symbol" id="moqapi-symbol" style="color: inherit; text-decoration: none;">
					<h2>MoqAPI symbol</h2>
				</a>
				<p>In some scenarios it is necessary to get Moq API from mocked object. For this purposes the library provides a predefined
				symbol MoqAPI. Mocked objects in their turns exposes a symbol property to access to its Moq API.</p>
				<p>Since this property makes sense only in context of the moq library and is not specific for mocked types it is not
				possible to define an interaction behaviour with Setup API.</p>
				<p>The property is read only and trackabel, so it possible to use for verification.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> func = <span class="hljs-keyword">new</span> Mock&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>&gt;()
    .object();

func[MoqAPI]
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance())
    .returns(<span class="hljs-number">12</span>);

<span class="hljs-keyword">const</span> actual = func();

expect(actual).toBe(<span class="hljs-number">12</span>);
</code></pre>
				<p>In operator does not sees this property until it is used in setups.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> Mock&lt;{}&gt;()
    .object();

expect(MoqAPI <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-literal">false</span>);
</code></pre>
				<p>BUT</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> mock = <span class="hljs-keyword">new</span> Mock&lt;ITestObject&gt;();
<span class="hljs-keyword">const</span> <span class="hljs-built_in">object</span> = mock
    .setup(<span class="hljs-function"><span class="hljs-params">instance</span> =&gt;</span> instance[MoqAPI])
    .returns(<span class="hljs-literal">undefined</span>)
    .object();

expect(MoqAPI <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>).toBe(<span class="hljs-literal">true</span>);
expect(<span class="hljs-built_in">object</span>[MoqAPI]).toBe(mock);
</code></pre>
				<blockquote>
					<p><a href="https://www.2bit.ch">Sponsored by 2BIT GmbH</a></p>
				</blockquote>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/moq_ts.html">moq.ts</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
</body>
</html>